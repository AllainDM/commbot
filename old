
@dp.message_handler(commands=['Кировский'])
async def self_message(message):
    await bot.send_message(message.chat.id, f"Ответ: Бот запущен")
    # while True:
    #     time.sleep(30)
    #     mes = parser.bot_start()
    #     try:
    #         if len(mes) > 0:
    #             # await bot.send_message(message.chat.id, f"Ответ: {mes}")
    #             x = 0
    #             for i in mes:
    #                 await bot.send_message(message.chat.id, f"Ответ: {mes[x]}")
    #                 x += 1
    #         else:
    #             print(f"{datetime.now()}: Новых ремонтов нет")
    #             file = open("logs.txt", "a")
    #             file.write(f"{datetime.now()}: Новых ремонтов нет \n")
    #             file.close()


def working():
    pass
    # file = open("logs.txt", "a")
    # file.write(f"{datetime.now()}: Программа запущена \n")
    # file.close()
    # while True:
    #     time.sleep(1800)
    #     file = open("logs.txt", "a")
    #     file.write(f"{datetime.now()}: Программа работает \n")
    #     file.close()


def start_parsing():
    mes = parser.bot_start()
    try:
        if len(mes) > 0:
            # await bot.send_message(message.chat.id, f"Ответ: {mes}")
            x = 0
            for i in mes:
                # await bot.send_message(message.chat.id, f"Ответ: {mes[x]}")
                send_telegram(mes[x])
                x += 1
        else:
            print(f"{datetime.now()}: Новых ремонтов нет")
            file = open("logs.txt", "a")
            file.write(f"{datetime.now()}: Новых ремонтов нет \n")
            file.close()
    except:
        print(f"{datetime.now()}: Ошибка с получением ответа от парсера")
        file = open("logs.txt", "a")
        file.write(f"{datetime.now()}: Ошибка с получением ответа от парсера \n")
        file.close()
        # await bot.send_message(message.chat.id, f"Ответ: Ошибка с получением ответа от парсера")
        send_telegram(f"Ответ: Ошибка с получением ответа от парсера")
    # bot_answer = True
    # print(f"{datetime.now()}: bot_answer = True")
    # finally:
    #     pass


def send_telegram(text):
    # text = format_text(offer)
    url = f'https://api.telegram.org/bot{config.BOT_API_TOKEN}/sendMessage'
    data = {
        'chat_id': config.chat_id,
        'text': text,
        'parse_mode': 'HTML'
    }
    requests.post(url=url, data=data)


def format_text():
    pass


def main():
    send_telegram("Бот запущен")
    # while True:
    #     time.sleep(10)
    #     start_parsing()
    # except e as n:
    #     send_telegram("Ошибка с таймером")
    #     print(f"{datetime.now()}: Ошибка с таймером")
    #     file = open("logs.txt", "a")
    #     file.write(f"{datetime.now()}: Ошибка с таймером \n")
    #     file.close()


if __name__ == '__main__':
    # executor.start_polling(dp)
    # working()
    main()


# # Кнопка ссылка
# urlkb = InlineKeyboardMarkup(row_width=1)
# urlButton = InlineKeyboardButton(text='Кировский', callback_data="address_1")
# urlButton2 = InlineKeyboardButton(text='Адмиралтейский', callback_data="address_2")
# urlkb.add(urlButton, urlButton2)


# @dp.callback_query_handler(Text(startswith="address_"))
# async def www_call(callback: types.CallbackQuery):
#     res = int(callback.data.split("_")[1])
#     print(res)
#     # bot.send_message(message.chat.id, f"Ответ: Центральный")
#     # if res == 1:
#     #     echo_mess_button(1)
#     # if f"{callback.from_user.id}" not in answ:
#     echo_mess_button(callback.from_user.id, res)
#     # await callback.answer()


# def echo_mess_button(message, num):
#     answer = []
#     if num == 1:
#         answer = get_html(url.url_link_kirov)
#     elif num == 2:
#         answer = get_html(url.url_link_admiral)
    # elif message == "3" or message == "Центр":
    #     await bot.send_message(message.chat.id, f"Ответ: Центральный")
    #     answer = get_html(url.url_link_central)
    # elif message == "4" or message == "Парфеновская":
    #     await bot.send_message(message.chat.id, f"Ответ: Парфеновская")
    #     answer = get_html(url.url_link_parf)
    # elif message == "5" or message == "Измайловский":
    #     await bot.send_message(message.chat.id, f"Ответ: Измайловский")
    #     answer = get_html(url.url_link_izmail)
    # elif message == "6" or message == "Фрунзенский":
    #     await bot.send_message(message.chat.id, f"Ответ: Фрунзенский")
    #     answer = get_html(url.url_link_frunz)
    # elif message == "7" or message == "Малая":
    #     await bot.send_message(message.chat.id, f"Ответ: Малая Митрофаньевская")
    #     answer = get_html(url.url_link_mitrof)
    # elif message == "8" or message == "Московский":
    #     await bot.send_message(message.chat.id, f"Ответ: Московский")
    #     answer = get_html(url.url_link_moscow)
    # elif message == "9" or message == "Петроградка":
    #     await bot.send_message(message.chat.id, f"Ответ: Петроградский")
    #     answer = get_html(url.url_link_petr)
    # elif message == "10" or message == "Васька":
    #     await bot.send_message(message.chat.id, f"Ответ: Василеостровский")
    #     answer = get_html(url.url_link_vas)
    # else:
    #     # await bot.send_message(message.chat.id, reply_markup=urlkb)
    #     await message.answer("Ссылки", reply_markup=urlkb)

    # try:
    #     if len(answer) > 0:
    #         # await bot.send_message(message.chat.id, f"Ответ: {mes}")
    #         for i in answer:
    #             # await bot.send_message(message.chat.id, f"Ответ: {answer[x]}")
    #             # await bot.send_message(message, i)
    #             await bot.send_message(message.chat.id, i)
    #             # send_telegram(mes[x])
    #     else:
    #         print(f"{datetime.now()}: Ремонтов нет")
    # except:
    #     print(f"{datetime.now()}: Ошибка с получением ответа от парсера")
    #     await bot.send_message(message.chat.id, f"Ответ: Ошибка с получением ответа от парсера")
    #     # await bot.send_message(message, f"Ответ: Ошибка с получением ответа от парсера")
